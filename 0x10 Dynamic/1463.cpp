#include <bits/stdc++.h>
using namespace std;

int n;          // 주어진 정수 N 저장
int d[1000010]; // 인덱스 i에 대해 i를 1로 만드는데 필요한 최소 연산 횟수 저장

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n;
    d[1] = 0;
    for (int i = 2; i <= n; i++)
    {
        d[i] = d[i - 1] + 1;
        if (i % 2 == 0)
            d[i] = min(d[i], d[i / 2] + 1);
        if (i % 3 == 0)
            d[i] = min(d[i], d[i / 3] + 1);
    }
    cout << d[n];
}

/*
예제 입력: 10

우리의 목표는 숫자 10을 1로 만드는데 필요한 최소 연산 횟수를 찾는 것입니다.

cin >> n;에서 입력으로 10을 받습니다.

d[1] = 0;에서 1을 만들기 위한 연산 횟수는 0입니다.

이제 for (int i = 2; i <= n; i++) 반복문을 사용하여 2부터 10까지 각 숫자에 대한 최소 연산 횟수를 계산합니다.

i = 2일 때,

d[2] = d[1] + 1 = 0 + 1 = 1 (1을 빼는 연산 1회)
i % 2 == 0이므로, d[2] = min(d[2], d[1] + 1) = min(1, 1) = 1
i = 3일 때,

d[3] = d[2] + 1 = 1 + 1 = 2 (1을 빼는 연산 2회)
i % 3 == 0이므로, d[3] = min(d[3], d[1] + 1) = min(2, 1) = 1 (3으로 나누는 연산 1회)
i = 4일 때,

d[4] = d[3] + 1 = 1 + 1 = 2 (1을 빼는 연산 2회)
i % 2 == 0이므로, d[4] = min(d[4], d[2] + 1) = min(2, 2) = 2 (2로 나누는 연산 1회, 1을 빼는 연산 1회)
i = 5일 때,

d[5] = d[4] + 1 = 2 + 1 = 3 (1을 빼는 연산 3회)
i = 6일 때,

d[6] = d[5] + 1 = 3 + 1 = 4 (1을 빼는 연산 4회)
i % 2 == 0이므로, d[6] = min(d[6], d[3] + 1) = min(4, 2) = 2 (2로 나누는 연산 1회, 1을 빼는 연산 1회)
i % 3 == 0이므로, d[6] = min(d[6], d[2] + 1) = min(2, 2) = 2
i = 7일 때,

d[7] = d[6] + 1 = 2 + 1 = 3 (1을 빼는 연산 3회)
i = 8일 때,

d[8] = d[7] + 1 = 3 + 1 = 4 (1을 빼는 연산 4회)
i % 2 == 0이므로, d[8] = min(d[8], d[4] + 1) = min(4, 3) = 3 (2로 나누는 연산 1회, 1을 빼는 연산 2회)
i = 9일 때,

d[9] = d[8] + 1 = 3 + 1 = 4 (1을 빼는 연산 4회)
i % 3 == 0이므로, d[9] = min(d[9], d[3] + 1) = min(4, 2) = 2 (3으로 나누는 연산 1회, 1을 빼는 연산 1회)
i = 10일 때,

d[10] = d[9] + 1 = 2 + 1 = 3 (1을 빼는 연산 3회)
i % 2 == 0이므로, d[10] = min(d[10], d[5] + 1) = min(3, 4) = 3 (2로 나누는 연산 1회, 1을 빼는 연산 2회)
마지막으로 cout << d[n];를 통해, d[10]의 값인 3을 출력합니다. 따라서 10을 1로 만드는 최소 연산 횟수는 3입니다.

왜 2로 나누어 떨어질때 d[i] =  min(d[i], d[i / 2] + 1 을 하고 3으로 나누어 떨어질때 d[i] = min(d[i], d[i / 3]  + 1을 하는거야?
이 문제에서 목표는 정수 N을 1로 만드는 데 필요한 최소 연산 횟수를 찾는 것입니다. 2로 나누거나, 3으로 나누거나, 1을 빼는 연산 중에서 최적의 조합을 찾아야 합니다.

d[i] = min(d[i], d[i / 2] + 1)와 d[i] = min(d[i], d[i / 3] + 1)를 사용하는 이유는 다음과 같습니다.

각각의 경우에 대해 최소 연산 횟수를 찾기 위해서입니다. 이미 계산된 d[i - 1] + 1 값(1을 빼는 연산)과 새로운 경우인 d[i / 2] + 1 또는 d[i / 3] + 1(2로 나누거나 3으로 나누는 연산) 중 작은 값을 선택하는 것입니다.

d[i / 2] + 1 또는 d[i / 3] + 1에서 + 1하는 이유는 현재 수를 2 또는 3으로 나누는 연산을 한 번 수행했다는 것을 나타내기 위함입니다. d[i / 2] 또는 d[i / 3]은 이미 해당 값까지 도달하는 데 필요한 최소 연산 횟수를 저장하고 있으므로, 현재 수에서 2 또는 3으로 나누는 연산을 추가하려면 1을 더해야 합니다.

이렇게 해서 각각의 경우에 대해 최소 연산 횟수를 구하고, 최종적으로 d[n]을 출력함으로써 정수 N을 1로 만드는 데 필요한 최소 연산 횟수를 찾을 수 있습니다.
*/